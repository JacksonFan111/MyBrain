<!DOCTYPE html>
<html>
    <head>
        <title>Jackson Fan : QI CIC section 15 to section 26</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Jackson Fan</a></span>
                            </li>
                                                    <li>
                                <span><a href="JF-Space-Overview_2554888272.html">JF Space Overview</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Jackson Fan : QI CIC section 15 to section 26
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                            
        
    
        
    
        
        
            Created by <span class='author'> Jackson Fan</span>, last modified on 11-06-25
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <style type='text/css'>/*<![CDATA[*/
div.rbtoc1755550429882 {padding: 0px;}
div.rbtoc1755550429882 ul {list-style: none;margin-left: 0px;}
div.rbtoc1755550429882 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1755550429882'>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-15—“Cursorengine”:explodingeachauditrow'>15 — “Cursor engine” : exploding each audit row</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Whyit’sdone'>Why it’s done</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-16—Normalise“table,GUID”patternsinOldValue'>16 — Normalise “table,GUID” patterns in OldValue</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.1'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.1'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-17—IdentifyPKofeachreferencetable'>17 — Identify PK of each reference table</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.2'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.2'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-18—Pick“best”display-namecolumnperlookup'>18 — Pick “best” display-name column per lookup</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.3'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.3'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-19—Executedynamiccurrent-valueSELECTs'>19 — Execute dynamic current-value SELECTs</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.4'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.4'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-20—TranslateOption-Setintegers→text'>20 — Translate Option-Set integers → text</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.5'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.5'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-21—PrepareSQLstringstoresolveGUIDs→names'>21 — Prepare SQL strings to resolve GUIDs → names</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.6'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.6'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-22&amp;23—RuntheGUID-to-namelook-ups'>22 &amp; 23 — Run the GUID-to-name look-ups</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.7'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.7'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-24—Build#Result1withEnglishlabels'>24 — Build #Result1 with English labels</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.8'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.8'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-25—Collapsetoone“Old→New”row'>25 — Collapse to one “Old → New” row</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.9'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints.9'>Review points</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-26—Finalreportwithbusinesscontext'>26 — Final report with business context</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whathappens.10'>What happens</a></li>
<li><a href='#QICICsection15tosection26-Reviewpoints&amp;ideas'>Review points &amp; ideas</a></li>
<li><a href='#QICICsection15tosection26-Quick“next-step”suggestions'>Quick “next-step” suggestions</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-TL;DR'>TL;DR</a></li>
<li><a href='#QICICsection15tosection26-Whythosemiddlesectionsare“re-usable”'>Why those middle sections are “re-usable”</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Whatyou’dtweaktomakeit100%generic'>What you’d tweak to make it 100 % generic</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-Whatisnotreusable(andmuststayoutsidetheadapter)'>What is not reusable (and must stay outside the adapter)</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Quickstarttoturnitintoauniversaladapter'>Quick start to turn it into a universal adapter</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-1Asingleauditrowasitsitsindbo.Audit'>1 A single audit row as it sits in dbo.Audit</a></li>
<li><a href='#QICICsection15tosection26-2Howthescriptcrackstherowopen'>2 How the script cracks the row open</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-2.1#temp–rawauditrow+metadata'>2.1 #temp – raw audit row + metadata</a></li>
<li><a href='#QICICsection15tosection26-2.2Explodemasksintolists'>2.2 Explode masks into lists</a></li>
<li><a href='#QICICsection15tosection26-2.3MetadataSchema.Attributetellsuswhatthosenumbersare'>2.3 MetadataSchema.Attribute tells us what those numbers are</a></li>
<li><a href='#QICICsection15tosection26-2.4#Atrib–onerowperchangedcolumn'>2.4 #Atrib – one row per changed column</a></li>
<li><a href='#QICICsection15tosection26-2.5#QueryStore–dynamicSELECTstofetchthecurrentvalue'>2.5 #QueryStore – dynamic SELECTs to fetch the current value</a></li>
<li><a href='#QICICsection15tosection26-2.6Option-set&amp;GUIDtranslation(Sections20–23)'>2.6 Option-set &amp; GUID translation (Sections 20–23)</a></li>
<li><a href='#QICICsection15tosection26-2.7Collapsingtothefinal“from→to”view(Section25)'>2.7 Collapsing to the final “from → to” view (Section 25)</a></li>
</ul>
</li>
<li><a href='#QICICsection15tosection26-3Glossary–thethreeconceptsinplainlanguage'>3 Glossary – the three concepts in plain language</a>
<ul class='toc-indentation'>
<li><a href='#QICICsection15tosection26-Take-away'>Take-away</a></li>
</ul>
</li>
</ul>
</div><p>Below is a “guided tour” of <strong>Sections 15 → 26</strong> of your <em>QI Audit &amp; Change-Log</em> script.<br/>For each block I first describe <strong>what it does</strong>, then give <strong>why it matters</strong>, and finally list <strong>review points / improvement ideas</strong> you might consider. I keep references to variable names so you can follow along in the source.</p><hr/><h2 id="QICICsection15tosection26-15—“Cursorengine”:explodingeachauditrow">15 — “Cursor engine” : exploding each audit row</h2><h3 id="QICICsection15tosection26-Whathappens">What happens</h3><ol start="1"><li><p><strong>Outer WHILE loop</strong> walks every row of <code>#temp</code> (one row ≈ one audit entry for one CRM record).</p><ul><li><p>Variables like <code>@table</code>, <code>@val</code>, <code>@Atrib</code>, <code>@OldVal</code> are loaded from that row.</p></li></ul></li><li><p><strong>AttributeMask split</strong></p><ul><li><p><code>@Atrib</code> (comma-list of changed column numbers) → inserted into <code>#Mask</code>.</p></li><li><p><code>@OldVal</code> (tilde-list of old values) → inserted into <code>#Vals</code>.</p></li></ul></li><li><p><strong>#Atrib build</strong> – joins each column number to CRM metadata to learn:</p><ul><li><p>Column <strong>logical name</strong>, data-type, whether it’s an <strong>Option Set</strong> (<code>IsStringMap</code>) or <strong>Lookup</strong> (<code>IsGUID</code>), etc.</p></li></ul></li><li><p><strong>Dynamic SELECT generation</strong></p><ul><li><p>For every column just inserted into <code>#Atrib</code> a <code>SELECT &lt;col&gt; … WHERE &lt;PK&gt;=…</code> statement is written to <code>#QueryStore</code>.</p></li><li><p>This will later be executed to fetch the <strong>current</strong> value of that column.</p></li></ul></li></ol><h3 id="QICICsection15tosection26-Whyit’sdone">Why it’s done</h3><ul><li><p>Audit masks only tell you <strong>which</strong> columns changed and their <strong>old</strong> values.<br/>To build a “<em>Old → New</em>” view you still have to fetch the <strong>current</strong> value.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints">Review points</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="53ed21ac-6188-489e-8edf-f95a134df258" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Area</p></th><th class="confluenceTh"><p>Comment</p></th></tr><tr><td class="confluenceTd"><p><strong>Row-by-row cursor</strong></p></td><td class="confluenceTd"><p>Fine for a handful of records, but will become slow if <code>#temp</code> is large. A set-based alternative (STRING_SPLIT + CROSS APPLY) would avoid repeated <code>TRUNCATE</code> and dynamic insert.</p></td></tr><tr><td class="confluenceTd"><p><strong>STRING_SPLIT</strong></p></td><td class="confluenceTd"><p>You note SQL 2008 limitations. If you ever move to SQL 2016+, replace the dynamic <code>INSERT</code> pattern with <code>STRING_SPLIT</code> – far simpler and faster.</p></td></tr><tr><td class="confluenceTd"><p><strong>Dynamic SQL safety</strong></p></td><td class="confluenceTd"><p>The dynamic statements pull table / column names from metadata (safe) <strong>and</strong> <code>@val</code> (GUID) from data. Because GUIDs are validated earlier, the risk of injection is very low but you could still parameterise the GUID with <code>sp_executesql</code>.</p></td></tr><tr><td class="confluenceTd"><p><strong>Temp-table resets</strong></p></td><td class="confluenceTd"><p><code>TRUNCATE TABLE</code> inside the loop is okay but the metadata for a table is still kept in TempDB. With thousands of iterations TempDB allocation can spike; a single, wider temp table plus a position column sometimes scales better.</p></td></tr></tbody></table></div><hr/><h2 id="QICICsection15tosection26-16—Normalise“table,GUID”patternsinOldValue">16 — Normalise “table,GUID” patterns in <code>OldValue</code></h2><h3 id="QICICsection15tosection26-Whathappens.1">What happens</h3><ul><li><p>Splits strings like <code>'contact,3F24…'</code> into <strong>table name</strong> and <strong>pure GUID</strong>.</p></li><li><p>Sets <code>IsGUID = 1</code> where necessary and fills <code>ReferenceTableName</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.1">Review points</h3><ul><li><p><code>TRY_CAST(… AS UNIQUEIDENTIFIER)</code> is a nice, cheap validity check.</p></li><li><p>Watch for performance if <code>OldValue</code> is <code>VARCHAR(MAX)</code> and rows ≫ 10 k: string ops become expensive; indexing <code>OldValue</code> is impossible. A computed/persisted column with the “cleaned” GUID could help if you ever store these long-term.</p></li></ul><hr/><h2 id="QICICsection15tosection26-17—IdentifyPKofeachreferencetable">17 — Identify PK of each reference table</h2><h3 id="QICICsection15tosection26-Whathappens.2">What happens</h3><ul><li><p>Uses <code>INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code> (already cached in <code>#PKs</code>) to map each reference table → its <strong>primary key column</strong> and writes that into <code>ReferenceTablePK</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.2">Review points</h3><ul><li><p>The join relies on <strong>physical</strong> table names. If the CRM schema ever changes (prefixes, suffixes) you might need a fallback that queries <code>MetadataSchema.Entity</code> for the PK instead.</p></li><li><p>Safe to assume every lookup entity has <strong>one-column</strong> PK (true for Dynamics/Dataverse).</p></li></ul><hr/><h2 id="QICICsection15tosection26-18—Pick“best”display-namecolumnperlookup">18 — Pick “best” display-name column per lookup</h2><h3 id="QICICsection15tosection26-Whathappens.3">What happens</h3><ul><li><p>Ranks all text columns for every lookup table and chooses the first match:<br/><code>Name</code>, <code>FullName</code>, <code>dsl_Name</code>, <code>Description</code>, or anything ending in <code>…Number</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.3">Review points</h3><ul><li><p>Clever heuristic, but ranking could be simplified with a CASE expression on <strong>AttributeDisplayName</strong> (if present in metadata).</p></li><li><p>Consider caching (<code>TABLE TYPE</code> + persisted table) because the calculation is deterministic and expensive to repeat.</p></li></ul><hr/><h2 id="QICICsection15tosection26-19—Executedynamiccurrent-valueSELECTs">19 — Execute dynamic <strong>current-value</strong> SELECTs</h2><h3 id="QICICsection15tosection26-Whathappens.4">What happens</h3><ul><li><p>Opens cursor over <code>#QueryStore</code>, runs each dynamic <code>SELECT</code>, places result into <code>#QueryStore.Value</code>.</p></li><li><p>Immediately updates <code>#AtribStore.CurrentValue</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.4">Review points</h3><ul><li><p>The <code>@Tab_CV</code> variable-table is re-created for every iteration and never exceeds one row – that’s fine.</p></li><li><p>Still cursor-based; again, a set-based approach (build one <code>UNION ALL</code> of all needed columns) would scream compared with thousands of dynamic execs.</p></li></ul><hr/><h2 id="QICICsection15tosection26-20—TranslateOption-Setintegers→text">20 — Translate Option-Set integers → text</h2><h3 id="QICICsection15tosection26-Whathappens.5">What happens</h3><ul><li><p>For any attribute flagged <code>IsStringMap = 1</code> and whose value is numeric, joins to <code>StringMap</code> and replaces code with label; also converts <code>True/False</code> to <code>Yes/No</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.5">Review points</h3><ul><li><p>Good use of <code>ISNUMERIC</code>. In SQL 2022 switch to <code>TRY_CONVERT(bigint, value) IS NOT NULL</code> (safer).</p></li><li><p>You run the query twice (OldValue and CurrentValue). Wrapping it in an inline TVF or view would remove duplication.</p></li></ul><hr/><h2 id="QICICsection15tosection26-21—PrepareSQLstringstoresolveGUIDs→names">21 — Prepare SQL strings to resolve GUIDs → names</h2><h3 id="QICICsection15tosection26-Whathappens.6">What happens</h3><ul><li><p>Builds one <strong>SELECT</strong> per GUID (Old &amp; New) that retrieves the chosen name column from the reference table, storing the SQL in the row.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.6">Review points</h3><ul><li><p>At this point every GUID lookup requires <strong>two more dynamic SQL executions</strong> → totals can explode. A single <strong>outer apply</strong> against each reference table could resolve <em>many</em> GUIDs in one hit (set-based again).</p></li></ul><hr/><h2 id="QICICsection15tosection26-22&amp;23—RuntheGUID-to-namelook-ups">22 &amp; 23 — Run the GUID-to-name look-ups</h2><h3 id="QICICsection15tosection26-Whathappens.7">What happens</h3><ul><li><p>Two more cursors (Old side then New side) execute the SQL stored above and overwrite <code>OldValue</code> / <code>CurrentValue</code> with the resolved text.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.7">Review points</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="bfcb0798-fb65-4367-b426-ec2811c7c902" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Area</p></th><th class="confluenceTh"><p>Comment</p></th></tr><tr><td class="confluenceTd"><p><strong>Concurrency</strong></p></td><td class="confluenceTd"><p>Between fetching the <em>current</em> value (section 19) and resolving GUID names (22/23) a row in Dynamics could change again, giving inconsistent snapshot. Not a problem for audit reporting but worth noting.</p></td></tr><tr><td class="confluenceTd"><p><strong>Indexes</strong></p></td><td class="confluenceTd"><p>Make sure the reference tables have an index on the PK column; otherwise you get one clustered-seek per GUID (fine) but risk table scans if schema changes.</p></td></tr></tbody></table></div><hr/><h2 id="QICICsection15tosection26-24—Build#Result1withEnglishlabels">24 — Build <code>#Result1</code> with English labels</h2><h3 id="QICICsection15tosection26-Whathappens.8">What happens</h3><ul><li><p>Joins <code>#AtribStore</code> to CRM metadata (<code>AttributeView</code>, <code>LocalizedLabelView</code>) so every technical name becomes an English display name.</p></li><li><p>Adds context from <code>#Objects</code> (Account, Contact, FTR, Beneficiary).</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.8">Review points</h3><ul><li><p>Filter <code>LanguageId = 1033</code> is hard-coded. If your tenant ever goes multilingual wrap that in a parameter.</p></li></ul><hr/><h2 id="QICICsection15tosection26-25—Collapsetoone“Old→New”row">25 — Collapse to one “Old → New” row</h2><h3 id="QICICsection15tosection26-Whathappens.9">What happens</h3><ul><li><p>Window function <code>LEAD</code> grabs the succeeding row (same Object &amp; Field) so you can show a before/after pair in one line.</p></li><li><p>Results written to <code>#FinalResult</code> where <code>OldValue &lt;&gt; NewValue</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints.9">Review points</h3><ul><li><p>Because <code>LEAD</code> operates on rows <em>after</em> section 24 grouping, sorting on both <code>Name, FieldName, CreatedOn</code> is correct.</p></li><li><p>Verify that audit rows sometimes arrive out-of-order (rare but possible); adding <code>CreatedOn, Action</code> to the ORDER BY of the window might help.</p></li></ul><hr/><h2 id="QICICsection15tosection26-26—Finalreportwithbusinesscontext">26 — Final report with business context</h2><h3 id="QICICsection15tosection26-Whathappens.10">What happens</h3><ul><li><p>Two <code>SELECT … UNION ALL …</code> blocks:</p><ol start="1"><li><p><strong>Entity rows</strong> (Account) – joined to extra Account columns like <code>dsl_PortfolioSearchingIDs</code>, tax-pool etc.</p></li><li><p><strong>Individual rows</strong> (Contact) – joined through <code>dsl_roles</code> to their owning Account.</p></li></ol></li><li><p>Outputs are <strong>already filtered to QI15</strong> via <code>cp.Value = 'QI15'</code>.</p></li><li><p>Final <code>ORDER BY ChangedDate DESC</code>.</p></li></ul><h3 id="QICICsection15tosection26-Reviewpoints&amp;ideas">Review points &amp; ideas</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="9ada5000-09d4-4cb9-9b1a-0d9c7ab359ec" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Topic</p></th><th class="confluenceTh"><p>Ideas</p></th></tr><tr><td class="confluenceTd"><p><strong>Performance head-room</strong></p></td><td class="confluenceTd"><p>By the time you reach section 26 you may have run <strong>thousands</strong> of tiny dynamic queries. If the audit window ever grows past 30 days, or the CRM activity spikes, consider: 1) Replacing cursors with set logic, 2) Caching common look-ups, 3) Executing everything inside one explicit <code>BEGIN TRAN</code> with <code>SNAPSHOT</code> isolation to guarantee consistency.</p></td></tr><tr><td class="confluenceTd"><p><strong>Temp-table life-cycle</strong></p></td><td class="confluenceTd"><p>Most temp tables survive until session end. Wrap the whole procedure in a stored proc so they drop automatically when the proc ends.</p></td></tr><tr><td class="confluenceTd"><p><strong>Error handling</strong></p></td><td class="confluenceTd"><p>Add <code>TRY…CATCH</code> around dynamic EXEC blocks so a single bad GUID/value doesn’t abort the entire run; log failed look-ups to a table.</p></td></tr><tr><td class="confluenceTd"><p><strong>Index hints</strong></p></td><td class="confluenceTd"><p>If the audit table is huge but has supporting non-clustered indexes on <code>(ObjectTypeCode, ObjectId, CreatedOn)</code> your section 10 join will stay fast. If not, add one.</p></td></tr><tr><td class="confluenceTd"><p><strong>Security</strong></p></td><td class="confluenceTd"><p>Because you query every entity table by name, the caller needs <strong>SELECT</strong> on all of them (Dynamics filtered views). Make the script a stored proc signed by an elevated certificate instead of granting direct SELECT on every CRM table.</p></td></tr></tbody></table></div><hr/><h3 id="QICICsection15tosection26-Quick“next-step”suggestions">Quick “next-step” suggestions</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="81b38906-690d-4b04-8fb3-5dbe21616fa4" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Goal</p></th><th class="confluenceTh"><p>Minimum change</p></th><th class="confluenceTh"><p>Bigger refactor</p></th></tr><tr><td class="confluenceTd"><p><strong>Speed up</strong></p></td><td class="confluenceTd"><p>Replace dynamic <code>INSERT INTO #Mask/#Vals</code> with <code>STRING_SPLIT</code> (SQL 2016+).</p></td><td class="confluenceTd"><p>Remove all three read-cursors (sections 15, 19, 22/23) and do one set-based explode with <code>CROSS APPLY</code> + <code>OUTER APPLY</code> for current values and GUID names.</p></td></tr><tr><td class="confluenceTd"><p><strong>Maintainability</strong></p></td><td class="confluenceTd"><p>Extract each section into its <strong>own stored proc</strong> so they can be unit-tested or swapped out. Document expected row counts &amp; runtime in comments.</p></td><td class="confluenceTd"><p>Turn the whole thing into an <strong>ETL pipeline</strong> (SSIS / Azure Data Factory) writing to an audit warehouse; keep only a lightweight <em>viewer</em> proc in CRM.</p></td></tr><tr><td class="confluenceTd"><p><strong>Reliability</strong></p></td><td class="confluenceTd"><p>Add <code>TRY…CATCH</code> wrappers around dynamic <code>EXEC</code> and write errors to a log table.</p></td><td class="confluenceTd"><p>Use <code>SNAPSHOT</code> isolation + <code>BEGIN TRAN</code> so every lookup sees a consistent database snapshot.</p></td></tr></tbody></table></div><hr/><h2 id="QICICsection15tosection26-TL;DR">TL;DR</h2><ul><li><p><strong>Section 15</strong> explodes each CRM audit blob into per-column rows and prepares dynamic SQL to pull “current” values.</p></li><li><p><strong>16–18</strong> tidy GUID/OptionSet metadata so text can replace codes.</p></li><li><p><strong>19–23</strong> execute that dynamic SQL (value look-ups + GUID → name).</p></li><li><p><strong>24–26</strong> assemble friendly labels, collapse to one Old → New line, add business context, and output the timeline.</p></li></ul><p>Everything works correctly but relies heavily on <em>row-by-row</em> cursors and dynamic SQL, which will hurt performance when the audit table grows. Moving the string splits and look-ups to <strong>set-based logic</strong> (or pre-built staging tables) is the single biggest win you could pursue next.</p><p>Let me know if you want example set-based rewrites for any of the culprits, or deeper dives into the OptionSet / GUID resolution steps.</p><p /><hr/><p>Short answer: <strong>yes — Sections 15 through 23 are basically a metadata-driven </strong><em><strong>adapter</strong></em><strong> you can drop into any Dynamics-CRM/Dataverse database to “crack open” the raw </strong><code>Audit</code><strong> table and turn it into human-readable rows.</strong><br/>Everything before Section 15 (where you build the #QI* temp-tables) and after Section 23 (where you bolt on QI-specific joins and labels) is the project-specific part.</p><hr/><h2 id="QICICsection15tosection26-Whythosemiddlesectionsare“re-usable”">Why those middle sections are “re-usable”</h2><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="1a9a6026-8843-402a-bf0c-af8676377392" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Block</p></th><th class="confluenceTh"><p>Generic job it does</p></th><th class="confluenceTh"><p>Anything hard-wired?</p></th></tr><tr><td class="confluenceTd"><p><strong>15. Cursor engine</strong></p></td><td class="confluenceTd"><p>Splits <code>AttributeMask</code> + <code>ChangeData</code>, converts column numbers → logical names using <code>MetadataSchema.Attribute</code>.</p></td><td class="confluenceTd"><p>Assumes SQL 2008 (no <code>STRING_SPLIT</code>), but otherwise entity-agnostic.</p></td></tr><tr><td class="confluenceTd"><p><strong>16. Normalise table,GUID</strong></p></td><td class="confluenceTd"><p>Cleans lookup values that come in “table,GUID” form.</p></td><td class="confluenceTd"><p>None.</p></td></tr><tr><td class="confluenceTd"><p><strong>17. PK discovery</strong></p></td><td class="confluenceTd"><p>Finds the PK column of every reference table from <code>INFORMATION_SCHEMA</code>.</p></td><td class="confluenceTd"><p>Relies on the PK being a single GUID (true for all Dataverse entities).</p></td></tr><tr><td class="confluenceTd"><p><strong>18. Pick display-name column</strong></p></td><td class="confluenceTd"><p>Ranks candidate columns (<code>Name</code>, <code>FullName</code>, …) so later GUID→name translation knows which column to read.</p></td><td class="confluenceTd"><p>Uses a heuristic list but no QI specifics.</p></td></tr><tr><td class="confluenceTd"><p><strong>19. Current-value fetch</strong></p></td><td class="confluenceTd"><p>Runs the dynamic <code>SELECT &lt;col&gt; …</code> statements stored in <code>#QueryStore</code> to pull <em>today’s</em> value.</p></td><td class="confluenceTd"><p>Dynamically built from metadata; no entity filter.</p></td></tr><tr><td class="confluenceTd"><p><strong>20. Option-set decode</strong></p></td><td class="confluenceTd"><p>Converts numeric option-set codes to text via <code>StringMap</code>.</p></td><td class="confluenceTd"><p>Works for any entity.</p></td></tr><tr><td class="confluenceTd"><p><strong>21–23. GUID→name look-ups</strong></p></td><td class="confluenceTd"><p>Builds and executes SQL to turn GUIDs into friendly names using the display column chosen in 18.</p></td><td class="confluenceTd"><p>Works for any lookup entity once 18 &amp; 17 succeed.</p></td></tr></tbody></table></div><h3 id="QICICsection15tosection26-Whatyou’dtweaktomakeit100%generic">What you’d tweak to make it 100 % generic</h3><ol start="1"><li><p><strong>Parameterise the object list</strong><br/>Replace the QI15-specific temp-tables (<code>#QIAccounts</code>, <code>#QIContacts</code>, …) with an input TVP or a simple <code>WHERE Audit.CreatedOn &gt;= @DateFrom AND Audit.CreatedOn &lt; @DateTo</code> and let the caller decide which entities to include.</p></li><li><p><strong>Externalise </strong><code>#ColMap</code></p><ul><li><p>Turn the hard-coded column list into a table-valued parameter.</p></li><li><p>Or let the consumer pass <em>either</em> a list of <code>ColumnNumber</code>s <em>or</em> plain logical field names and resolve them inside.</p></li></ul></li><li><p><strong>Wrap 15 → 23 in a stored procedure</strong></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">EXEC dbo.usp_DecodeAudit
     @StartDate     = &#39;2025-05-01&#39;,
     @EndDate       = &#39;2025-05-31&#39;,
     @EntityOTCs    = &#39;1,2,10307,10075&#39;,   -- Accounts, Contacts, FTR, Beneficiary
     @ColumnNumbers = &#39;22,10017,10342,…&#39;;
</pre>
</div></div><p>The proc would return a tidy result set (equivalent to your <code>#Result1</code>) for whatever the caller asked.</p></li><li><p><strong>Make language / locale a parameter</strong> (<code>@LangId = 1033</code>).</p></li><li><p><strong>Optional</strong>: swap the row-by-row cursors for set-based <code>CROSS APPLY</code> logic so performance scales when you drop it into another tenant.</p></li></ol><hr/><h2 id="QICICsection15tosection26-Whatisnotreusable(andmuststayoutsidetheadapter)">What is <em>not</em> reusable (and must stay outside the adapter)</h2><ul><li><p>Sections 0–14: the QI-specific object harvesting (Accounts flagged <code>QI15</code>, BO roles, Foreign-Tax-Record joins, Trust-Beneficiary joins, etc.).</p></li><li><p>Sections 24–26: final enrichment that tacks on portfolio IDs, PSL ranks, role labels, and rolls the output into your business report.</p></li></ul><p>Think of the whole script as <strong>“generic audit-decoder core” (15-23) wrapped in “QI business shell” (2–14, 24-26).</strong><br/>Lift the core into its own procedure and you can call it from other reports, SSIS jobs, or Power BI refreshes any time you need a readable audit stream for <em>any</em> entity in CRM.</p><hr/><h3 id="QICICsection15tosection26-Quickstarttoturnitintoauniversaladapter">Quick start to turn it into a universal adapter</h3><ol start="1"><li><p><strong>CREATE PROC dbo.usp_CRM_GetAuditReadable</strong><br/><em>Parameters</em>: <code>@FromDate</code>, <code>@ToDate</code>, <code>@EntityOTCs</code>, <code>@ColumnNumbers</code>, <code>@LangId</code>.</p></li><li><p>Move Sections 15–23 inside; replace references to temp-tables created earlier with the procedure parameters.</p></li><li><p>Return the result of Section 24 (<strong>without</strong> the QI joins).</p></li><li><p>Your QI report script then becomes just:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">;WITH Raw AS (
    EXEC dbo.usp_CRM_GetAuditReadable
         @FromDate = DATEADD(day,-30,GETDATE()),
         @ToDate   = GETDATE(),
         @EntityOTCs = &#39;1,2,10307,10075&#39;,
         @ColumnNumbers = (SELECT STRING_AGG(ColumnNumber, &#39;,&#39;)
                           FROM dbo.My_QI_FieldList)
)
SELECT …              -- QI joins from Sections 24-26
FROM   Raw
…
</pre>
</div></div></li></ol><p>Now you have a clean, reusable “adapter” layer for decoding the Dynamics <code>Audit</code> table, and a thinner downstream query that applies whatever business rules you need for the current project.</p><p /><hr/><p>Below is a <strong>mini “toy” audit-record</strong> that we’ll decode end-to-end.<br/>The numbers are tiny so you can step through the same places in your script and see exactly what each object does.</p><hr/><h2 id="QICICsection15tosection26-1Asingleauditrowasitsitsindbo.Audit">1 A single audit row as it sits in <code>dbo.Audit</code></h2><div class="table-wrap"><table data-layout="default" data-local-id="dc8dba29-da63-46de-a641-d7fae166c1a1" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>AuditId</p></th><th class="confluenceTh"><p>ObjectTypeCode</p></th><th class="confluenceTh"><p>ObjectId</p></th><th class="confluenceTh"><p>AttributeMask</p></th><th class="confluenceTh"><p>ChangeData</p></th><th class="confluenceTh"><p>CreatedOn</p></th><th class="confluenceTh"><p>UserIdName</p></th></tr><tr><td class="confluenceTd"><p>…</p></td><td class="confluenceTd"><p><strong>1</strong> (Account)</p></td><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p><code>{22,10366}</code></p></td><td class="confluenceTd"><p><code>Acme Ltd~NZ</code></p></td><td class="confluenceTd"><p>2025-06-10</p></td><td class="confluenceTd"><p>Jackson</p></td></tr></tbody></table></div><p><em>What it means</em></p><ul><li><p>Column <strong>22</strong> and <strong>10366</strong> changed on the Account whose PK (GUID) is <code>A7E9…</code>.</p></li><li><p>The <strong>old</strong> values for those two columns were <code>Acme Ltd</code> (for column 22) and <code>NZ</code> (for column 10366).</p></li><li><p>The <strong>new</strong> values are <em>not</em> in the audit row; they are whatever is in the current Account table.</p></li></ul><hr/><h2 id="QICICsection15tosection26-2Howthescriptcrackstherowopen">2 How the script cracks the row open</h2><h3 id="QICICsection15tosection26-2.1#temp–rawauditrow+metadata">2.1 <code>#temp</code> – raw audit row + metadata</h3><p>Section 14 copies the audit row into <code>#temp</code> and adds the table’s physical name and its PK column:</p><div class="table-wrap"><table data-layout="default" data-local-id="359e687c-88c3-440d-bbf0-4f30ac119610" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>ID</p></th><th class="confluenceTh"><p>TableName</p></th><th class="confluenceTh"><p>PrimaryColName</p></th><th class="confluenceTh"><p>ObjectId</p></th><th class="confluenceTh"><p>AttributeMask</p></th><th class="confluenceTh"><p>ChangeData</p></th></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p><code>Account</code></p></td><td class="confluenceTd"><p><code>AccountId</code></p></td><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p><code>22,10366</code></p></td><td class="confluenceTd"><p><code>Acme Ltd~NZ</code></p></td></tr></tbody></table></div><p><em>(Braces </em><code>{}</code><em> removed and leading/trailing spaces trimmed.)</em></p><hr/><h3 id="QICICsection15tosection26-2.2Explodemasksintolists">2.2 Explode masks into lists</h3><p>Inside the Section 15 loop:</p><div class="table-wrap"><table data-layout="default" data-local-id="7267bd57-8f2a-41eb-8cb4-998b09158fa2" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>#Mask</p></th><th class="confluenceTh"><p>#Vals</p></th></tr><tr><td class="confluenceTd"><p>22</p></td><td class="confluenceTd"><p>Acme Ltd</p></td></tr><tr><td class="confluenceTd"><p>10366</p></td><td class="confluenceTd"><p>NZ</p></td></tr></tbody></table></div><hr/><h3 id="QICICsection15tosection26-2.3MetadataSchema.Attributetellsuswhatthosenumbersare">2.3 <code>MetadataSchema.Attribute</code> tells us what those numbers are</h3><div class="table-wrap"><table data-layout="default" data-local-id="29b373cd-91fc-41ac-8ffb-82a604ea9b68" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>ColumnNumber</p></th><th class="confluenceTh"><p>Name (logical)</p></th><th class="confluenceTh"><p>AttributeLogicalTypeId</p></th><th class="confluenceTh"><p>OptionSetId</p></th><th class="confluenceTh"><p>ReferencedEntityOTC</p></th></tr><tr><td class="confluenceTd"><p>22</p></td><td class="confluenceTd"><p><strong>Name</strong></p></td><td class="confluenceTd"><p>String</p></td><td class="confluenceTd"><p>NULL</p></td><td class="confluenceTd"><p>0</p></td></tr><tr><td class="confluenceTd"><p>10366</p></td><td class="confluenceTd"><p><strong>cip_CountryOfIncorporation…</strong></p></td><td class="confluenceTd"><p>Lookup (GUID)</p></td><td class="confluenceTd"><p>NULL</p></td><td class="confluenceTd"><p><strong>104</strong> (Country)</p></td></tr></tbody></table></div><p><em>(Your database’s values can be queried like </em><code>SELECT ColumnNumber, Name … FROM MetadataSchema.Attribute WHERE ColumnNumber IN (22,10366)</code><em>.)</em></p><hr/><h3 id="QICICsection15tosection26-2.4#Atrib–onerowperchangedcolumn">2.4 <code>#Atrib</code> – one row per changed column</h3><div class="table-wrap"><table data-layout="default" data-local-id="261691da-ad78-48c0-aafe-f4ff5dcca4c3" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>PrimaryColValue</p></th><th class="confluenceTh"><p>TargetFieldNo</p></th><th class="confluenceTh"><p>TargetFieldName</p></th><th class="confluenceTh"><p>OldValue</p></th><th class="confluenceTh"><p>IsStringMap</p></th><th class="confluenceTh"><p>IsGUID</p></th><th class="confluenceTh"><p>RefTable</p></th><th class="confluenceTh"><p>RefOTC</p></th></tr><tr><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p>22</p></td><td class="confluenceTd"><p>Name</p></td><td class="confluenceTd"><p>Acme Ltd</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p>NULL</p></td><td class="confluenceTd"><p>NULL</p></td></tr><tr><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p>10366</p></td><td class="confluenceTd"><p>cip_CountryOfIncorporation…</p></td><td class="confluenceTd"><p>NZ</p></td><td class="confluenceTd"><p>0</p></td><td class="confluenceTd"><p><strong>1</strong></p></td><td class="confluenceTd"><p>Country</p></td><td class="confluenceTd"><p>104</p></td></tr></tbody></table></div><p>Key points:</p><ul><li><p><code>IsGUID = 1</code> for column 10366 because it’s a <strong>lookup</strong> field.</p></li><li><p>The audit row only gave us the <em>code</em> <code>NZ</code>; we’ll need to turn that into “New Zealand”.</p></li></ul><hr/><h3 id="QICICsection15tosection26-2.5#QueryStore–dynamicSELECTstofetchthecurrentvalue">2.5 <code>#QueryStore</code> – dynamic SELECTs to fetch the <strong>current</strong> value</h3><div class="table-wrap"><table data-layout="default" data-local-id="687df6b6-ac7f-4cc5-84f4-38f81066c818" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>ObjectId</p></th><th class="confluenceTh"><p>FieldName</p></th><th class="confluenceTh"><p>SQLCommand</p></th></tr><tr><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p>Name</p></td><td class="confluenceTd"><p><code>SELECT Name FROM Account WHERE AccountId = 'A7E9…'</code></p></td></tr><tr><td class="confluenceTd"><p><code>A7E9…</code></p></td><td class="confluenceTd"><p>cip_CountryOfIncorporation…</p></td><td class="confluenceTd"><p><code>SELECT cip_CountryOfIncorporation… FROM Account WHERE AccountId = 'A7E9…'</code></p></td></tr></tbody></table></div><p>Later (Section 19) the script executes each command and writes the result into <code>#QueryStore.Value</code>, then copies that into <code>#AtribStore.CurrentValue</code>.</p><p>Assume the current values are <code>Acme Corporation</code> and <code>US</code>.</p><hr/><h3 id="QICICsection15tosection26-2.6Option-set&amp;GUIDtranslation(Sections20–23)">2.6 Option-set &amp; GUID translation (Sections 20–23)</h3><ol start="1"><li><p>Column 22 is plain text – nothing to translate.</p></li><li><p>Column 10366 is a GUID lookup:</p><ul><li><p><code>NZ</code> and <code>US</code> are <strong>primary keys in the Country table</strong>.</p></li><li><p>Section 18 picked the display column (perhaps <code>CountryName</code>).</p></li><li><p>Section 22/23 runs<br/><code>SELECT CountryName FROM Country WHERE CountryId = 'NZ'</code> → <em>“New Zealand”</em><br/><code>SELECT CountryName FROM Country WHERE CountryId = 'US'</code> → <em>“United States”</em></p></li></ul></li></ol><p>After translation <code>#AtribStore</code> now holds:</p><div class="table-wrap"><table data-layout="default" data-local-id="ca9aed3f-aef7-46fe-8e61-435b7f17cd32" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>FieldName</p></th><th class="confluenceTh"><p>OldValue</p></th><th class="confluenceTh"><p>CurrentValue</p></th></tr><tr><td class="confluenceTd"><p>Name</p></td><td class="confluenceTd"><p>Acme Ltd</p></td><td class="confluenceTd"><p>Acme Corporation</p></td></tr><tr><td class="confluenceTd"><p>Country</p></td><td class="confluenceTd"><p>New Zealand</p></td><td class="confluenceTd"><p>United States</p></td></tr></tbody></table></div><hr/><h3 id="QICICsection15tosection26-2.7Collapsingtothefinal“from→to”view(Section25)">2.7 Collapsing to the final “from → to” view (Section 25)</h3><div class="table-wrap"><table data-layout="default" data-local-id="638cf9ef-c3d6-42b9-866d-b480f93b424f" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Field changed</p></th><th class="confluenceTh"><p>From</p></th><th class="confluenceTh"><p>To</p></th><th class="confluenceTh"><p>When (NZ time)</p></th><th class="confluenceTh"><p>Who</p></th></tr><tr><td class="confluenceTd"><p>Name</p></td><td class="confluenceTd"><p>Acme Ltd</p></td><td class="confluenceTd"><p>Acme Corporation</p></td><td class="confluenceTd"><p>2025-06-10</p></td><td class="confluenceTd"><p>Jackson</p></td></tr><tr><td class="confluenceTd"><p>Country</p></td><td class="confluenceTd"><p>New Zealand</p></td><td class="confluenceTd"><p>United States</p></td><td class="confluenceTd"><p>2025-06-10</p></td><td class="confluenceTd"><p>Jackson</p></td></tr></tbody></table></div><hr/><h2 id="QICICsection15tosection26-3Glossary–thethreeconceptsinplainlanguage">3 Glossary – the three concepts in plain language</h2><div class="table-wrap"><table data-layout="default" data-local-id="04785520-c80c-4ec2-9281-967fe6a12973" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Term</p></th><th class="confluenceTh"><p>Think of it as…</p></th><th class="confluenceTh"><p>In our tiny example</p></th></tr><tr><td class="confluenceTd"><p><strong>AttributeMask</strong></p></td><td class="confluenceTd"><p><em>“List of column numbers that changed.”</em>Stored as digits so the Audit table stays small.</p></td><td class="confluenceTd"><p><code>{22,10366}</code></p></td></tr><tr><td class="confluenceTd"><p><strong>MetadataSchema.Attribute</strong></p></td><td class="confluenceTd"><p><em>“Phone-book that converts a column number to its real field.”</em>Also tells you the data type (string, lookup, option-set, etc.).</p></td><td class="confluenceTd"><p><code>22 → Name10366 → cip_CountryOfIncorporation… (lookup to Country)</code></p></td></tr><tr><td class="confluenceTd"><p><strong>#Atrib / #AtribStore</strong></p></td><td class="confluenceTd"><p><em>“Scratchpad rows – one per (record, field) change, carrying everything we know so far.”</em>That includes old value, new value (once looked up), flags that tell later code whether it needs extra translation, and the SQL needed to do it.</p></td><td class="confluenceTd"><p>See tables in 2.4 and 2.6</p></td></tr></tbody></table></div><hr/><h3 id="QICICsection15tosection26-Take-away">Take-away</h3><p><em>The heavy lifting is just mapping <strong>numbers ➜ field names</strong> and then mapping <strong>codes ➜ friendly text</strong>.</em><br/>Once that mapping is in place, everything else in the script is straightforward SQL joins or dynamic look-ups.</p><hr/><p>Let me know if you’d like to practise with another field type (e.g., an <strong>Option Set</strong> or a <strong>bit/boolean</strong>) or if you want a quick demo on how to replace the cursor splits with <code>STRING_SPLIT</code> for modern SQL versions.</p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on 18-08-25 20:53</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
