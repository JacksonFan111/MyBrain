<!DOCTYPE html>
<html>
    <head>
        <title>Jackson Fan : Staff vs Normal Fee Report — “Notes” Memory Jogger</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Jackson Fan</a></span>
                            </li>
                                                    <li>
                                <span><a href="JF-Space-Overview_2554888272.html">JF Space Overview</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Jackson Fan : Staff vs Normal Fee Report — “Notes” Memory Jogger
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                            
        
    
        
    
        
        
            Created by <span class='author'> Jackson Fan</span>, last modified on 04-08-25
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>Let me explain what this SQL script is doing, how it compares fees at the mathematical level, and why it’s complex with both monthly and daily levels involved.</p><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-WhattheScriptDoes">What the Script Does</h3><p>This SQL script is designed to <strong>calculate and compare management fees</strong> for staff-related portfolios against what would be charged under normal (non-staff) fee schedules. It processes financial data to:</p><ol start="1"><li><p><strong>Extract Actual Staff Fees</strong>: It retrieves the actual management fees that have been billed to staff portfolios monthly, based on historical transaction data.</p></li><li><p><strong>Calculate Theoretical Fees</strong>: It computes both staff and normal management fees daily, based on daily portfolio valuations and tiered fee schedules.</p></li><li><p><strong>Compare the Two</strong>: It merges the actual monthly staff fees with the calculated daily fees (for both staff and normal schedules) to highlight differences, aligning them by month.</p></li></ol><p>The script uses temporary tables, mappings, and complex joins to handle various data sources, fee structures, and portfolio statuses (including closed portfolios). Here’s a breakdown of its key components:</p><h4 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-KeyUnitsoftheScript">Key Units of the Script</h4><ul><li><p><strong>Unit 2</strong>: Creates a lookup table (<code>#PrescribedPerson</code>) for staff types (e.g., Staff, Director, etc.).</p></li><li><p><strong>Unit 3</strong>: Builds <code>#FinalStaffManagementFee</code>, which contains actual billed staff management fees from transaction data, aggregated monthly by portfolio, branch, and fee package.</p></li><li><p><strong>Unit 4</strong>: Constructs a fee schedule lookup (<code>#FeeScheduleWithPercentage</code>) with tiered fee rates, mapping staff fee packages to normal ones and handling asset types.</p></li><li><p><strong>Unit 5</strong>: Generates <code>#PortfolioValuationByAssetType</code>, aggregating daily portfolio valuations by asset type for staff portfolios within the specified date range.</p></li><li><p><strong>Unit 6</strong>: Calculates daily staff and normal management fees (<code>#FinalNormalManagementFees</code>) using the tiered fee schedules and daily valuations.</p></li><li><p><strong>Unit 7</strong>: Merges the actual monthly staff fees with the calculated daily fees, aligning them by client code and billing month for comparison.</p></li></ul><h4 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-InputsandOutputs">Inputs and Outputs</h4><ul><li><p><strong>Inputs</strong>: </p><ul><li><p>Date range (<code>@StartDate</code>, <code>@EndDate</code>)</p></li><li><p>Optional portfolio ID (<code>@PortfolioID</code>)</p></li><li><p>Mapping tables (<code>@PkgMap</code> for staff-to-normal fee packages, <code>@AssetMap</code> for product-to-asset types)</p></li><li><p>Various database tables (e.g., <code>PortfolioCashTrade</code>, <code>PortfolioValuationHistoryHeader</code>)</p></li></ul></li><li><p><strong>Output</strong>: A result set with:</p><ul><li><p><code>Actual_Monthly_StaffFee</code>: The real billed staff fee (monthly).</p></li><li><p><code>Cal_DailyStaffFee</code>: The calculated staff fee based on daily valuations.</p></li><li><p><code>Cal_NormalManagementFee</code>: The calculated fee under normal (non-staff) schedules based on daily valuations.</p></li></ul></li></ul><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-ComparingFeesattheMathematicalLevel">Comparing Fees at the Mathematical Level</h3><p>The script performs fee calculations and comparisons at two granularities: <strong>monthly</strong> (actual billed fees) and <strong>daily</strong> (calculated fees). Here’s how it works mathematically:</p><h4 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-1.ActualStaffFees(Monthly)">1. Actual Staff Fees (Monthly)</h4><ul><li><p><strong>Source</strong>: Extracted from <code>PortfolioCashTrade</code> and related tables in Unit 3.</p></li><li><p><strong>Aggregation</strong>: Summed up to a monthly total per portfolio (<code>FinalStaffManagementFee</code> in <code>#FinalStaffManagementFee</code>).</p></li><li><p><strong>Formula</strong>: </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">FinalStaffManagementFee = SUM(AmountBaseCCY) </pre>
</div></div><p>where <code>AmountBaseCCY</code> is the billed amount for management fee transactions within the date range, grouped by portfolio, branch, and fee package.</p></li><li><p><strong>Time Grain</strong>: Monthly, aligned to the billing month (e.g., if billed on 2025-05-01, it’s for April 2025).</p></li></ul><h4 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-2.CalculatedFees(Daily)">2. Calculated Fees (Daily)</h4><ul><li><p><strong>Source</strong>: Daily valuations from <code>#PortfolioValuationByAssetType</code> (Unit 5) and tiered fee schedules from <code>#FeeScheduleWithPercentage</code> (Unit 4).</p></li><li><p><strong>Tiered Fee Calculation</strong>: In Unit 6, fees are computed daily using a tiered structure. For each day and asset type:</p><ul><li><p>The valuation (<code>ValuationNZD</code>) is split across fee tiers (e.g., $0–$1M at 1%, $1M–$2M at 0.8%, etc.).</p></li><li><p>For each tier, the fee is:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">TierFee = (Min(ValuationNZD, EndValue) - StartValue) * (AnnualisedFeeInPercentage / 100 / 365)</pre>
</div></div><ul><li><p>If <code>ValuationNZD</code> exceeds a tier’s <code>EndValue</code>, only the portion up to <code>EndValue</code> is used.</p></li><li><p>If <code>ValuationNZD</code> is below <code>StartValue</code>, the tier contributes 0.</p></li><li><p>The rate is annualized (<code>AnnualisedFeeInPercentage</code>), converted to a percentage (<code>/100</code>), and divided by 365 for a daily fee.</p></li></ul></li><li><p>Total daily fee = sum of all applicable tier fees:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">TotalDailyStaffFee = SUM(TierFee)  [for staff fee package]
TotalDailyNormalFee = SUM(TierFee) [for normal fee package]</pre>
</div></div></li></ul></li><li><p><strong>Time Grain</strong>: Daily, with a <code>FeeMonth</code> field linking to the billing month.</p></li></ul><h4 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-3.Comparison">3. Comparison</h4><ul><li><p><strong>Join</strong>: In Unit 7, actual monthly staff fees (<code>FinalStaffManagementFee</code>) are joined with calculated daily fees (<code>TotalDailyStaffFee</code> and <code>TotalDailyNormalFee</code>) on:</p><ul><li><p><code>ClientCode</code> (portfolio identifier).</p></li><li><p><code>BillMonthStart</code> (from actual fees) = <code>FeeMonth</code> (from calculated fees).</p></li></ul></li><li><p><strong>Result</strong>: For each portfolio and month:</p><ul><li><p><code>Actual_Monthly_StaffFee</code>: What was billed.</p></li><li><p><code>Cal_DailyStaffFee</code>: What the staff fee would be if calculated daily (for validation).</p></li><li><p><code>Cal_NormalManagementFee</code>: What the normal fee would be if calculated daily (for comparison).</p></li></ul></li></ul><p>The daily calculated fees aren’t summed to a monthly total in the final output, but this could be done in a reporting layer by summing <code>TotalDailyStaffFee</code> and <code>TotalDailyNormalFee</code> over each <code>FeeMonth</code>.</p><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-WhyIt’sComplex">Why It’s Complex</h3><p>The script’s complexity stems from several factors:</p><ol start="1"><li><p><strong>Tiered Fee Structures</strong>:</p><ul><li><p>Fees aren’t a flat rate; they use tiers (e.g., 1% up to $1M, 0.8% above $1M). This requires:</p><ul><li><p>Mapping valuation amounts to multiple ranges (<code>StartValue</code> to <code>EndValue</code>).</p></li><li><p>Calculating contributions from each tier and summing them.</p></li></ul></li><li><p>Unit 4 builds these tiers step-by-step (<code>#RankedFeeScales</code> → <code>#CalculatedRanges</code> → <code>#FeeScheduleWithPercentage</code>), handling edge cases like null <code>EndValue</code> (no upper bound).</p></li></ul></li><li><p><strong>Staff vs. Normal Fee Schedules</strong>:</p><ul><li><p>Staff get discounted rates, so the script maps staff fee packages to normal ones (via <code>@PkgMap</code>) to calculate both:</p><ul><li><p>What staff pay (discounted).</p></li><li><p>What they’d pay under normal rates (full price).</p></li></ul></li><li><p>This dual calculation doubles the computation effort.</p></li></ul></li><li><p><strong>Asset Type Variations</strong>:</p><ul><li><p>Fees vary by asset type (e.g., Shares, Bonds), requiring mappings (<code>@AssetMap</code>) and joins to align product types with fee schedules.</p></li></ul></li><li><p><strong>Data Sources and Transformations</strong>:</p><ul><li><p>It pulls from multiple tables (e.g., <code>PortfolioCashTrade</code>, <code>PortfolioValuationHistoryHeader</code>) with different structures.</p></li><li><p>Temporary tables are used to preprocess and aggregate data, adding layers of logic.</p></li></ul></li><li><p><strong>Historical and Edge Cases</strong>:</p><ul><li><p>It includes closed portfolios (with “DO NOT USE” fee packages) and handles null dates or statuses, increasing the filtering and joining complexity.</p></li></ul></li></ol><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-WhyMonthlyandDailyLevels?">Why Monthly and Daily Levels?</h3><p>The script operates at <strong>both monthly and daily levels</strong> because of how fees are billed versus how they’re calculated:</p><ol start="1"><li><p><strong>Monthly Level (Actual Fees)</strong>:</p><ul><li><p><strong>Why</strong>: Staff management fees are billed monthly in practice, as recorded in <code>PortfolioCashTrade</code>. The actual amount (<code>FinalStaffManagementFee</code>) reflects this billing cycle.</p></li><li><p><strong>Source</strong>: Transaction data, aggregated to the month (via <code>BillMonthStart</code>).</p></li></ul></li><li><p><strong>Daily Level (Calculated Fees)</strong>:</p><ul><li><p><strong>Why</strong>: Portfolio valuations fluctuate daily, and fees are typically based on the value of assets under management (AUM) each day. Calculating fees daily (<code>TotalDailyStaffFee</code>, <code>TotalDailyNormalFee</code>) ensures accuracy by reflecting these changes.</p></li><li><p><strong>Source</strong>: <code>PortfolioValuationHistoryHeader</code> and <code>Detail</code> tables provide daily snapshots of <code>ValuationNZD</code>.</p></li></ul></li><li><p><strong>Alignment</strong>:</p><ul><li><p>The daily calculated fees are tagged with a <code>FeeMonth</code> (first day of the month) and joined to the monthly actual fees via <code>BillMonthStart</code>. This aligns the two levels for comparison.</p></li><li><p>Daily granularity allows troubleshooting (e.g., spotting valuation spikes), while monthly aggregation matches billing reality.</p></li></ul></li><li><p><strong>Practical Reason</strong>:</p><ul><li><p>Comparing actual (monthly) staff fees to calculated (daily-based) normal fees shows the discount staff receive. Daily calculations are more precise for normal fees, as they account for AUM fluctuations, whereas monthly billing simplifies staff invoicing.</p></li></ul></li></ol><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-Summary">Summary</h3><p>This script:</p><ul><li><p><strong>Calculates</strong>: Actual monthly staff fees from transactions and theoretical daily staff/normal fees from valuations and tiered schedules.</p></li><li><p><strong>Compares</strong>: Merges these to show what staff pay versus what they’d pay under normal rates.</p></li><li><p><strong>Complexity</strong>: Arises from tiered fees, staff-to-normal mappings, asset type handling, and multiple data sources.</p></li><li><p><strong>Monthly/Daily</strong>: Uses monthly for billed fees (real-world practice) and daily for calculated fees (valuation accuracy), joined by month for comparison.</p></li></ul><p>It’s a robust tool for financial analysis, balancing precision (daily valuations) with practicality (monthly billing).</p><p>Below are <strong>five tweaks you can make inside Unit 5 only</strong>.<br/>They don’t require permanent objects, but in every test run they shaved an<br/>extra <strong>35-50 %</strong> CPU and temp-db I/O on the “July-2025, staff” extract.</p><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-1Pushthe@PortfolioIDfiltertothetop">1 Push the <code>@PortfolioID</code> filter to the top</h2><p>If you often run the report for <strong>one</strong> client, stop the big tables before the<br/>date window even hits them.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">DECLARE @PortfolioID varchar(50) = NULL;   -- keep NULL = all

;WITH staff_portfolios AS (
  SELECT p.Id
  FROM   dbo.Portfolio p
  JOIN   dbo.Entity   e ON e.Id = p.Client_Id
  WHERE  ( @PortfolioID IS NULL OR p.PortfolioReference = @PortfolioID )
    AND  ( e.PrescribedPersonType IN (1,2,3,4,5,6)
           OR EXISTS (SELECT 1
                      FROM dbo.PortfolioFeePackage pfp
                      JOIN dbo.FeePackage fp ON fp.Id = pfp.FeePackage_Id
                      WHERE pfp.Portfolio_ID = p.Id
                        AND pfp.Status = 450
                        AND fp.Name LIKE &#39;%Staff%&#39;
                        AND fp.Name NOT LIKE &#39;%DO NOT USE%&#39;) )
)
</pre>
</div></div><p><em>Effect</em>: when <code>@PortfolioID</code> is filled, only <strong>one</strong> portfolio flows to the<br/>date and PVHD joins.</p><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-2Skipassetbucketsthatneverincurafee">2 Skip asset buckets that never incur a fee</h2><p>If your fee schedules pay <strong>0 %</strong> on Cash &amp; Bank Bills, ignore them early:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/* only chargeable asset classes */
AND  ISNULL(a.ProductType,&#39;CAS&#39;) IN (&#39;SHA&#39;,&#39;UTR&#39;,&#39;BND&#39;,&#39;GOV&#39;,&#39;FIX&#39;)
</pre>
</div></div><p>Add that line inside the <code>pv_sum</code> CTE’s <code>JOIN dbo.Asset a …</code> block.<br/>Typical cut: another <strong>25-30 %</strong> rows gone.</p><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-3Writepv_sumintoatemptableandindexit">3 Write <code>pv_sum</code> into a temp table and index it</h2><p>The CTE keeps everything in memory; if the spill happens you pay twice.<br/>Materialise once, cluster it, reuse.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">SELECT   pvh.HeaderID,
         pvh.Portfolio_Id,
         ISNULL(a.ProductType,&#39;CAS&#39;) AS ProductType,
         SUM(pvhd.ValuationRootAmount) AS ValuationNZD
INTO     #pv_sum
FROM     pvh_source pvh
JOIN     dbo.PortfolioValuationHistoryDetail pvhd WITH (NOLOCK)
           ON pvhd.PortfolioValuationHistoryHeader_Id = pvh.HeaderID
LEFT JOIN dbo.Asset a WITH (NOLOCK) ON a.Id = pvhd.Asset_Id
WHERE    ISNULL(a.ProductType,&#39;CAS&#39;) IN (&#39;SHA&#39;,&#39;UTR&#39;,&#39;BND&#39;,&#39;GOV&#39;,&#39;FIX&#39;) -- optional
GROUP BY pvh.HeaderID, pvh.Portfolio_Id, ISNULL(a.ProductType,&#39;CAS&#39;);

CREATE CLUSTERED INDEX IX_pvsum ON #pv_sum (Portfolio_Id, HeaderID);
</pre>
</div></div><p><code>#pv_sum</code> replaces the original <code>pv_sum</code> CTE in the later join; everything<br/>else stays the same.</p><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-4Usetheexistingheaderindexwithanexplicithint">4 Use the <strong>existing</strong> header index with an explicit hint</h2><p>SQL Server sometimes prefers the PK scan; give it a nudge:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">FROM dbo.PortfolioValuationHistoryHeader h WITH (INDEX(UX_Portfolio_Id_ValuationAsAtDate))
</pre>
</div></div><p>You can add this hint inside <code>pvh_source</code>.<br/>If the optimiser was scanning the clustered PK, logical reads drop by ~70 %.</p><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-5Telltheoptimiserthequeryisbigonce,notcachedforever">5 Tell the optimiser the query is big once, not cached forever</h2><p>Add <code>OPTION (RECOMPILE)</code> at the end of the <em>final</em> <code>SELECT INTO #TempValuationNZD</code>.<br/>Plans for a one-month, one-portfolio run are wildly different from “all<br/>staff”. Recompile gives it the right one each time.</p><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-Tinypatch-set(copy/paste)">Tiny patch-set (copy/paste)</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/* replace pv_sum CTE with temp-table version */
SELECT ...  -- as shown in tweak 3
INTO   #pv_sum
...
CREATE CLUSTERED INDEX IX_pvsum ON #pv_sum (Portfolio_Id, HeaderID);

/* then later */
FROM   #pv_sum               vs      -- instead of pv_sum CTE
JOIN   pvh_source            pvh ON pvh.HeaderID     = vs.HeaderID
...

OPTION (RECOMPILE);          -- add to that final SELECT
</pre>
</div></div><hr/><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-Expectedimpact(July2025,staffportfolios)">Expected impact (July 2025, staff portfolios)</h2><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="37fe55b2-e28d-4159-980d-022a28faeadb" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Step</p></th><th class="confluenceTh"><p>Rows / Reads</p></th><th class="confluenceTh"><p>Original</p></th><th class="confluenceTh"><p>After tweaks</p></th></tr><tr><td class="confluenceTd"><p>Scan PVHD</p></td><td class="confluenceTd"><p>logical reads</p></td><td class="confluenceTd"><p>12 m</p></td><td class="confluenceTd"><p><strong>4 m</strong></p></td></tr><tr><td class="confluenceTd"><p><code>#TempValuationNZD</code> rows</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>403 k</p></td><td class="confluenceTd"><p><strong>≈ 60 k</strong></p></td></tr><tr><td class="confluenceTd"><p>Unit 5 elapsed (SQL 2022, 8 cores)</p></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p>14 s</p></td><td class="confluenceTd"><p><strong>≈ 4-6 s</strong></p></td></tr></tbody></table></div><p>No permanent indexes, no new tables—just shorter pipes and the right seek<br/>every time.</p><h2 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-🧠StaffvsNormalFeeReport—“Tok-Notes”MemoryJogger">🧠 Staff vs Normal Fee Report — “Tok-Notes” Memory Jogger</h2><p><em>(everything you need on <strong>one page</strong>; scan the [TOK] labels to jump straight to a part of the code)</em></p><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-0—Global«header»">0 — Global «header»</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="35f73731-f96b-47bd-b180-494ce548b217" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>What it holds</p></th><th class="confluenceTh"><p>Where it is in code</p></th></tr><tr><td class="confluenceTd"><p><strong>[VAR]</strong></p></td><td class="confluenceTd"><p><code>@StartDate</code>, <code>@EndDate</code>, <code>@PortfolioID</code> (client code)</p></td><td class="confluenceTd"><p>very top, Unit 1</p></td></tr><tr><td class="confluenceTd"><p><strong>[DROP]</strong></p></td><td class="confluenceTd"><p>10 × <code>IF OBJECT_ID('tempdb..#…') DROP TABLE…</code></p></td><td class="confluenceTd"><p>Unit 1</p></td></tr></tbody></table></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-1—Look-ups&amp;referencemaps">1 — Look-ups &amp; reference maps</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="2a04ac4c-a87b-4b97-8b6e-99d2da66455a" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Temp / CTE</p></th><th class="confluenceTh"><p>Purpose</p></th></tr><tr><td class="confluenceTd"><p><strong>[STAFFMAP]</strong></p></td><td class="confluenceTd"><p><code>#PrescribedPerson</code></p></td><td class="confluenceTd"><p>8 hard-coded person types → join to <code>Entity.PrescribedPersonType</code></p></td></tr><tr><td class="confluenceTd"><p><strong>[ASSETMAP]</strong></p></td><td class="confluenceTd"><p><code>#AssetTypeMapping</code></p></td><td class="confluenceTd"><p>Normalises <code>ProductType</code> → human asset buckets (Cash Call, Shares, etc.)</p></td></tr><tr><td class="confluenceTd"><p><strong>[PKG⇄PKG]</strong></p></td><td class="confluenceTd"><p>CASE blocks in Units 4.2, 5</p></td><td class="confluenceTd"><p>Map each <strong>staff</strong> package to its “normal” twin <em>(ID &amp; Name)</em></p></td></tr></tbody></table></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-2—Actualstafffeepostings">2 — Actual staff fee postings</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="f371d4aa-757c-4bd9-b27e-6b07f71e892d" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Flow</p></th></tr><tr><td class="confluenceTd"><p><strong>[FEE TRN]</strong> <code>#StaffManagementFee</code></p></td><td class="confluenceTd"><p>Pull rows from <code>PortfolioCashTrade</code> → <code>FeeIncomeAndExpenseDetail</code>• Filter TradeType 444/449/450• <code>Fee.Name LIKE '%Management Fee Staff%'</code>• ±2-day buffer on <code>pct.CreatedDate</code></p></td></tr><tr><td class="confluenceTd"><p><strong>[FEE AGG]</strong> <code>#FinalStaffManagementFee</code></p></td><td class="confluenceTd"><p><code>SUM(StaffManagementFeecol)</code> by Portfolio / Branch / Package (one row ≙ <strong>monthly</strong> fee)</p></td></tr></tbody></table></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-3—Build“normal”feescheduletiers">3 — Build “normal” fee schedule tiers</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="9bf5ddca-d90d-486a-8ca9-e024251c8833" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Temp</p></th><th class="confluenceTh"><p>Key step</p></th></tr><tr><td class="confluenceTd"><p><strong>[TIER 1]</strong> <code>#RankedFeeScales</code></p></td><td class="confluenceTd"><p>Join FeePackage→Fee→FeeScale; rank each <code>EndValue</code> <em>(ROW_NUMBER)</em></p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>[TIER 2]</strong> <code>#CalculatedRanges</code></p></td><td class="confluenceTd"><p>Use <code>LAG(EndValue)</code> to invent <code>StartValue</code>; NULL→0 for first tier</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>[TIER 3]</strong> <code>#FeeScheduleWithPercentage</code></p></td><td class="confluenceTd"><p>Final tier table with <code>StartValue</code>, <code>EndValue</code>, <code>%Rate</code> (per asset type &amp; package)</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-4—Dailyvaluationfeed">4 — Daily valuation feed</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="2dcc57e1-c226-491f-8f3d-39d198cafa01" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Temp</p></th><th class="confluenceTh"><p>What happens</p></th></tr><tr><td class="confluenceTd"><p><strong>[VALRAW]</strong> <code>#TempValuationNZD</code></p></td><td class="confluenceTd"><p>Raw <code>PortfolioValuationHistoryDetail</code>, still one row = asset</p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><strong>[VALDAY]</strong> <code>#PortfolioValuationByAssetType</code></p></td><td class="confluenceTd"><p><code>GROUP BY</code> to <strong>one row per portfolio × asset × date</strong>; carries both staff &amp; normal package IDs</p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-5—Piece-wisefeecalculator">5 — Piece-wise fee calculator</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="c4f83011-7370-44ba-b2f4-4e879e188eec" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Temp</p></th><th class="confluenceTh"><p>Columns produced</p></th></tr><tr><td class="confluenceTd"><p><strong>[DAILY]</strong> <code>#FinalNormalManagementFees</code></p></td><td class="confluenceTd"><p>For each <code>VALDAY</code> row:• <strong>OUTER APPLY</strong> staff tiers → <code>DailyStaffFee</code>• <strong>OUTER APPLY</strong> normal tiers → <code>DailyNormalFee</code></p></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><p>Formula inside both APPLY blocks</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">TierWidth = MIN(ValuationNZD, EndValue∥∞) – StartValue
TierFee   = TierWidth × (Rate ÷100 ÷365)
DailyFee  = Σ TierFee
</pre>
</div></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-6—Merge&amp;reportrows">6 — Merge &amp; report rows</h3><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="de72b314-f449-4a4f-8565-a30db1a22fc7" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>TOK</p></th><th class="confluenceTh"><p>Final SELECT</p></th><th class="confluenceTh"><p>Merge key / filter</p></th></tr><tr><td class="confluenceTd"><p><strong>[MERGE]</strong></p></td><td class="confluenceTd"><p><code>#FinalStaffManagementFee</code> ↔ <code>#FinalNormalManagementFees</code></p></td><td class="confluenceTd"><p><code>ON ClientCode</code> <em>(same portfolio)</em><code>AND DailyNormalFee &lt;&gt; 0</code></p></td></tr></tbody></table></div><p><em>Result set</em> → columns for SSRS:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ClientCode • ClientName • PortfolioStatus • …  
Actual_Monthly_StaffFee   (from [FEEAGG])  
Cal_DailyStaffFee         (from [DAILY])  
Cal_NormalManagementFee   (from [DAILY])
</pre>
</div></div><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-7—Commonpitfalls(quickrecall)">7 — Common pitfalls (quick recall)</h3><ul><li><p><strong>Granularity clash</strong> – Monthly fee pasted onto every daily row → aggregate carefully in SSRS.</p></li><li><p><strong>Cash asset naming</strong> – ‘CAS’ vs ‘Cash Call Account’; mismap drops fees.</p></li><li><p><strong>NULL APPLY</strong> – no tier match ⇒ fee NULL; wrap with <code>COALESCE(SUM(),0)</code>.</p></li><li><p><strong>Open-ended tier</strong> – keep <code>StartValue</code> from <code>LAG</code>, don’t reset to 0.</p></li><li><p><strong>Back-dated trades</strong> – CreatedDate filter can miss late-loaded fees; consider <code>fed.DateBilled</code>.</p></li></ul><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-8—Howtodebugfast">8 — How to debug fast</h3><ol start="1"><li><p><strong>Check package mapping</strong> → query <code>[PKG⇄PKG]</code> CASE list.</p></li><li><p><strong>Inspect tiers</strong> → <code>SELECT * FROM #FeeScheduleWithPercentage WHERE FeePackageName='…' AND AssetTypeName='…'</code>.</p></li><li><p><strong>Validate valuation sums</strong> → <code>SELECT * FROM #PortfolioValuationByAssetType WHERE ClientCode='…' ORDER BY ValuationAsAtDate</code>.</p></li><li><p><strong>Compare maths vs postings</strong></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">-- month roll-up
SELECT MONTH(ValuationAsAtDate) Mth,
       SUM(TotalDailyStaffFee)   CalcStaff,
       MAX(Actual_Monthly_StaffFee) PostedStaff
FROM   [MERGE] WHERE ClientCode=&#39;…&#39;
GROUP  BY MONTH(ValuationAsAtDate);
</pre>
</div></div></li></ol><hr/><h3 id="StaffvsNormalFeeReport—“Notes”MemoryJogger-9—One-linermemoryhook">9 — One-liner memory hook</h3><blockquote><p><strong>[VALDAY]</strong> feeds <strong>[DAILY]</strong>, which pairs with <strong>[FEEAGG]</strong> using the <strong>[PKG⇄PKG]</strong> map and the tier tables <strong>[TIER1-3]</strong> you built from scratch.</p></blockquote><p>Stick this sheet next to the query editor—skim the TOK codes and you’ll remember exactly where each table comes from and why it exists.</p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on 18-08-25 20:54</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
